---
layout: ../../layouts/MarkdownLayout.astro
title: Component Library
author: Dante Nardo
description: Learn about my experience building a component library for a SAAS platform!
---

import { Image } from "astro:assets";
import ComponentDocumentationCode from "../../images/biosero-component-documentation-code.png";
import ComponentDocumentationDark from "../../images/biosero-component-documentation-dark.png";
import ComponentDocumentationLight from "../../images/biosero-component-documentation-light.png";
import ComponentLibraryForm from "../../images/biosero-component-library-form.png";
import ArticleCaption from '../../components/article/ArticleCaption.tsx';
import ArticleImage from '../../components/article/ArticleImage.astro';
import ArticleLink from '../../components/article/ArticleLink.tsx';
import Badge from '../../components/badge/Badge.tsx';
import BadgeList from '../../components/badge/BadgeList.tsx';

# Component Library
As Biosero transitioned from desktop software to web, we quickly found the need to distribute our components across several web apps. I took the initiative to create a general purpose component library. 

## Build Faster
Biosero developers can easily add static UI elements like badges, interactive elements like dropdowns, and complex behaviors like focus traps to their application with my component library. The design supports both light and dark mode with theming possible through CSS variables.

<ArticleImage>
  <Image src={ComponentDocumentationDark} alt="This image depicts a documentation website that shows all the ways to display a button component including adding icons, loading spinners, and changing its accent style." />
</ArticleImage>
<ArticleCaption>The dark theme button documentation</ArticleCaption>

<ArticleImage>
  <Image src={ComponentDocumentationLight} alt="This image depicts a documentation website that shows part of the button component documentation but with the light theme instead of the dark theme." />
</ArticleImage>
<ArticleCaption>The light theme button documentation</ArticleCaption>

## Documented Like a Pro
One of the consequences of using Blazor is that there is far less documentation tooling compared to the JavaScript ecosystem. Building the library was the first challenge; the second was finding a way to make it easy for software engineers across Biosero to discover and use the components in their projects.

I built a documentation site much like Storybook in order to accomplish this. Developers can find over 100 components with samples for how each property affects its appearance or behavior. When they find what they need they can view the code of the live sample they're seeing on the screen and paste it into their project.

<ArticleImage>
  <Image src={ComponentDocumentationCode} alt="This image depicts a documentation website with a Toast component that shows all of the code a developer would need to use the component in their own app." />
</ArticleImage>
<ArticleCaption>The syntax-highlighted code samples to use Toasts in an app</ArticleCaption>

## Supercharged Forms
While Blazor comes with a built-in form system, it has a lot of drawbacks. I ended up creating a new form system I dubbed `Formkit` for reliable validation, error handling, and custom styling. The forms and their elements are highly composable with dynamic validation messages in markup and support for every basic `HTML` input property.

<ArticleImage>
  <Image src={ComponentLibraryForm} alt="This image depicts a documentation website with a form generated by the code above." />
</ArticleImage>
<ArticleCaption>A form generated using Fieldkit components</ArticleCaption>

The form above was generated by the following code:

```razor
<Form OnSubmit=@BasicOnSubmit OnValidSubmit=@BasicOnValidSubmit class="flex flex-col max-w-sm gap-4">
    <FieldGroup Name="email">
        <FieldLabel>Email</FieldLabel>
        <FieldText @bind-Value=@_model.Email Event="oninput" type="email" />
        <FieldValidation FailWhen=@(() => { return string.IsNullOrEmpty(_model.Email); })>
            Email is required
        </FieldValidation>
        <FieldValidationParsing />
    </FieldGroup>
    <FieldGroup Name="password">
        <FieldLabel>Password</FieldLabel>
        <FieldText @bind-Value=@_model.Password Event="oninput" type="password" />
        <FieldValidation FailWhen=@(() => { return string.IsNullOrEmpty(_model.Password); })>
            Password is required
        </FieldValidation>
        <FieldValidation FailWhen=@(() => { return string.IsNullOrEmpty(_model.Password) || !Regex.IsMatch(_model.Password, "^[a-zA-Z0-9]*$"); })>
            Password can only contain alphanumeric characters
        </FieldValidation>
        <FieldValidationParsing />
    </FieldGroup>
    <FieldGroup Name="date of birth">
        <FieldLabel>Date of Birth</FieldLabel>
        <FieldDate @bind-Value=@_model.DateOfBirth Event="oninput" />
        <FieldValidationParsing />
    </FieldGroup>
    <FieldGroup Name="role">
        <FieldLabel>Role</FieldLabel>
        <FieldSelect @bind-Value=@_model.Role>
            <FieldSelectOption Value=@("")>Select an option</FieldSelectOption>
            <FieldSelectOption Value=@("Administrator")>Administrator</FieldSelectOption>
            <FieldSelectOption Value=@("Moderator")>Moderator</FieldSelectOption>
            <FieldSelectOption Value=@("Plebeian")>Plebeian</FieldSelectOption>
        </FieldSelect>
        <FieldValidationParsing />
    </FieldGroup>
    <div class="flex">
        <Button Primary type="submit" Text="Submit" Fluid />
    </div>
</Form>
```

## Technical Details
- Documentation built using <Badge>Blazor</Badge> and <Badge>ASP.NET Core</Badge>
- Components built with <Badge>Blazor</Badge>, <Badge>JavaScript</Badge>, and <Badge>Tailwind CSS</Badge>
- Syntax highlighting using <Badge>Prism</Badge>
- Deployed to <Badge>Azure</Badge> via <Badge>GitHub</Badge> CI/CD